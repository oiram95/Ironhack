<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Functions- CallBacks</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-gradient-to-r from-gray-100 to-blue-100">
    <!-- <div class="conatiner p-4">
      <h1>Advanced Functions- CallBacks</h1>
      <h1 class="font-bold">Que veremos?</h1>
      <ul class="list-disc p-4">
        <li>Usar expresiones</li>
        <li>pasar funciones a otras funciones como argumentos</li>
        <li>
          comprender el comportamiento as铆ncrono de JavaScript y la necesidad de
          las devoluciones de llamada
        </li>
        <li>utilizar funciones an贸nimas</li>
        <li>utilizar funciones de flecha</li>
        <li>utilizar el objeto arguments</li>
      </ul>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">Introduction</h1>
      <p>
        Como ya se mencion贸 en la lecci贸n de introducci贸n a las funciones,
        podemos declarar funciones de 3 maneras diferentes: como una declaraci贸n
        de funci贸n (aka statements), como expresiones de funci贸n y como una
        instancia del constructor de objetos de funci贸n global.
      </p>
      <p>
        Miremos la funcion llamada <strong class="font-bold">calcSum</strong>
      </p>
      <ul class="list-disc px-4">
        <li class="py-2">
          function es una palabra clave reservada y sirve para indicar que un
          determinado bloque de c贸digo a ejecutar estar谩 envuelto bajo un
          determinado nombre
        </li>
        <li class="py-2">
          (x, y) son los par谩metros que se pasar谩n en la funci贸n y que se
          utilizar谩n entre {...} que representa el cuerpo de la funci贸n; son
          marcadores de posici贸n que se sustituir谩n por valores reales en el
          momento en que se ejecute esta funci贸n la sentencia return muestra
          cu谩l ser谩 el valor devuelto por la funci贸n. Adem谩s, dijimos que el
          retorno es la 煤ltima pieza de c贸digo que se ejecuta dentro de la
          funci贸n y que si a帽adimos alg煤n c贸digo despu茅s del retorno por
          accidente - no se ejecutar谩
        </li>
        <li class="py-2">
          calcSum(12, 23) es la llamada a la funci贸n, cuando la funci贸n se
          ejecuta con algunos valores reales pasados en lugar de x e y. 12 y 23
          son argumentos de la funci贸n
        </li>
      </ul>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">Function expressions</h1>
      <p>
        Ahora que sabemos c贸mo declarar e invocar funciones con nombre
        <span class="font-bold">(function statements)</span>, va a ser muy f谩cil
        explicar c贸mo hacer lo mismo con expresiones de funci贸n. Antes de
        mostrarte c贸mo trabajar con expresiones de funci贸n, debemos mencionar
        brevemente que las funciones son tratadas como los llamados objetos de
        primera clase en JavaScript. Esto puede parecer confuso: 驴las funciones
        son objetos? Sin embargo, al final de este curso, sabr谩 c贸mo y por qu茅
        "todo en JavaScript es un objeto", incluidas las funciones. Si est谩s
        interesado en aprender m谩s sobre este tema, consulta la secci贸n de
        Recursos Extra m谩s adelante. Debido a que las funciones son tratadas
        como objetos, significa que pueden ser asignadas a variables (es decir,
        pueden ser almacenadas en variables). Esto nos lleva a las expresiones
        de funciones. Veamos este ejemplo de declaraci贸n de funci贸n:
      </p>
    </div> -->

    <!-- <div class="container p-4">
      <h1 class="font-bold">Function declaration vs. function expressions</h1>
      <div class="container bg-white rounded-md mx-auto px-4 w-full mt-4">
        <p>
          Una function declaration es una funci贸n con nombre y puede almacenarse
          en una variable si es necesario (por ejemplo, con el saludo). Una
          expresi贸n de funci贸n es una funci贸n sin nombre (o llamada an贸nima) que
          se almacena en una variable. Ambas pueden reutilizarse en todo el
          c贸digo.
        </p>
        <br />
        <p>
          Function expressions & function declarations hacen pr谩cticamente lo
          mismo.
          <br />
          En ambos ejemplos, para llamarlas se hace lo mismo (welcomeMessage()),
          y luego ejecutan cualquier c贸digo que est茅 dentro de su bloque de
          c贸digo (tambi茅n conocido como cuerpo de la funci贸n) {..} . Entonces,
          驴por qu茅 tenemos que conocer ambos? Bueno, hay una diferencia y no
          est谩 relacionada con lo que hacen, sino con c贸mo se ejecutan. La
          diferencia entre estos dos es el orden en que se ejecuta el c贸digo.
          Mira esto:
        </p>
      </div>
      <p>VER CODIGO</p>
      <p>
        Para entender por qu茅 y c贸mo ocurri贸 esto, introduciremos el concepto de
        Hoisting
      </p>
      <div class="container bg-white rounded-md mx-auto px-4 w-full mt-4">
        <p>
          EL Hoisting es un concepto relacionado con la forma en que el lenguaje
          de programaci贸n es interpretado por una m谩quina que lo ejecuta. Este
          concepto est谩 relacionado con cualquier tipo de variables y tipos de
          datos, y no est谩 correlacionado con las funciones solamente.
        </p>
      </div>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">Hoisting</h1>
      <p>
        Cuando el c贸digo JavaScript se ejecuta, lo hace de arriba a abajo y
        luego de izquierda a derecha. Esto significa que lo que hayamos escrito
        en la l铆nea 1 de nuestro fragmento de c贸digo se ejecutar谩 antes de lo
        que venga en la l铆nea 2, y lo que est茅 en la l铆nea 2 se ejecutar谩 antes
        de la l铆nea 3 y as铆 sucesivamente. Esto implica que, para utilizar una
        variable, es necesario declararla primero. Sin embargo, este no es el
        caso cuando se trata de declaraciones de funciones. Las declaraciones de
        funciones se elevan a la parte superior del c贸digo antes de que se
        ejecute cualquier otro c贸digo.
        <br />
        Pero, 驴c贸mo se produce este proceso de elevaci贸n de las declaraciones de
        funci贸n? Antes de que se ejecute cualquier c贸digo, tu c贸digo JavaScript
        necesita ser interpretado (traducido a un c贸digo comprensible para el
        navegador). Es en este proceso de interpretaci贸n donde las declaraciones
        de funciones se elevan a la parte superior del c贸digo, y es por eso que
        podemos llamar a una funci贸n antes incluso de declararla. As铆 que cuando
        llega la fase de ejecuci贸n, las declaraciones de funciones ya est谩n
        interpretadas y cargadas. Esto significa que no necesitamos definirlas
        para poder utilizarlas.
        <br />
        El mismo proceso no ocurre con las expresiones de funciones. Se
        interpretan en la l铆nea exacta en la que se escriben, por lo que s贸lo
        podemos utilizarlas despu茅s de haberlas definido.
      </p>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">CallBacks</h1>
      <p>
        Como ya hemos mencionado, las funciones son objetos de primera clase y,
        como tales, pueden almacenarse en variables. Como este es el caso, las
        funciones pueden ser pasadas como par谩metros (argumentos) a otras
        funciones. Nos referimos a esto como una devoluci贸n de llamada.
        <br />
        Las devoluciones de llamada son una herramienta que permite a las
        funciones llamar a otras funciones y puede ayudarnos con el control de
        la secuencia, es decir, el orden en el que queremos que se ejecuten
        nuestras funciones. Esto puede ser particularmente 煤til en
        circunstancias en las que queremos que una funci贸n se ejecute antes que
        otra.
        <br />
        Hablaremos de los callbacks con m谩s detalle en la pr贸xima lecci贸n, pero
        por ahora recuerda que son un ejemplo de funci贸n avanzada.
      </p>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">Anonymous Functions</h1>
      <div class="container bg-white rounded-md mx-auto px-4 w-full mt-4">
        <ul class="list-disc px-4">
          <li>Un anonymous function es una funcion sin nombre</li>
          <li>
            Una funci贸n an贸nima no suele estar disponible para su uso despu茅s de
            su creaci贸n inicial. La raz贸n para crear una funci贸n sin nombre es
            que s贸lo se utilizar谩 en ese momento exacto y nunca m谩s, por lo que
            realmente no hay necesidad de nombrarlas
          </li>
        </ul>
      </div>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">
        Anonymous functions as other functions arguments
      </h1>
      <p>
        Las funciones an贸nimas se pueden utilizar como un argumento que se pasa
        a otra funci贸n.
        <br />
        He aqu铆 algunos ejemplos:
      </p>
      <p>Revisar Codigo</p>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">Arrow Functions</h1>
      <p>
        Seg煤n la documentaci贸n oficial, una expresi贸n de funci贸n de flecha es
        una alternativa sint谩ctica a una expresi贸n de funci贸n regular.
        <br />
        Esta actualizaci贸n se introdujo con ES6 y su objetivo principal era
        introducir una sintaxis m谩s sencilla y ayudar con algunos retos
        anteriores relacionados con el 谩mbito con funciones/m茅todos anidados.
        <br />
        Echemos un vistazo a una funci贸n de flecha:
      </p>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">
        The <span class="text-2xl">this</span> keyword and the matter of a scope
      </h1>
      <p>
        Explicaremos este concepto con m谩s detalle en una de las pr贸ximas
        lecciones, pero por ahora, vamos a cubrir lo b谩sico.
        <br />
        Veamos el siguiente ejemplo - un objeto simple con 3 propiedades, donde
        una de ellas es un m茅todo:
      </p>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">The arguments object</h1>
      <p>
        Dentro del cuerpo de una funci贸n, puedes acceder a un objeto llamado
        argumentos. Este objeto representa todos los argumentos pasados a una
        funci贸n. Lo espec铆fico relacionado con 茅l es que se trata de un objeto
        tipo array. Seg煤n el MDN, "array-like" significa que los argumentos
        tienen una propiedad de longitud y propiedades indexadas desde cero,
        pero no tiene los m茅todos incorporados de los arrays como forEach() (y
        otros que cubriremos pronto).
      </p>
    </div>

    <div class="container p-4">
      <h1 class="font-bold">En Resumen</h1>
      <p>
        En esta lecci贸n, has aprendido otra forma de definir funciones en
        JavaScript: utilizando funciones como expresiones. Esencialmente no hay
        mayor diferencia entre la declaraci贸n de funciones y la expresi贸n,
        excepto cuando se trata de interpretarlas en nuestros ordenadores.
      </p>
      <br />
      <p>
        Hemos aprendido que las declaraciones de funciones se levantan y pueden
        ser llamadas antes de ser definidas en el c贸digo, lo que tiene
        implicaciones positivas y negativas. Las expresiones de funciones
        imponen un c贸digo mejor estructurado.
      </p>
      <br />
      <p>
        Aprendimos que las funciones pueden pasarse como argumentos a otras
        funciones, y luego vimos c贸mo se ve eso en el caso de los cierres.
      </p>
      <br />
      <p>
        Aprendimos que algunas funciones s贸lo pueden usarse una vez, por lo que
        no es necesario nombrarlas (tambi茅n conocidas como funciones an贸nimas).
      </p>
      <p>
        El ES6 trajo una forma mucho m谩s agradable y corta de escribir funciones
        usando la sintaxis de expresi贸n de funci贸n de flecha.
      </p>
      <p>
        Y finalmente, vimos que las funciones por defecto tienen acceso a los
        argumentos en sus cuerpos, y vimos un par de casos de uso.
      </p>
    </div> -->

    <div class="container p-4">
      <h1 class="font-bold">Callback function</h1>
      <button id="callbackbutton" class="p-4 bg-gray-900 text-white">
        Click Me
      </button>
    </div>
  </body>
  <script src="index.js"></script>
  <!-- <script>
    //Hemo aprendido la manera convencional de usar funciones
    function calcSum(x, y) {
      return x + y;
    }

    checkFuncDeclaration();
    // console.log(calcSum(2, 4));

    // function declaration (statement)

    const welcomeMessage = (message) => {
      return message;
    };

    const greeting = welcomeMessage("So nice to have you here! Welcome!");
    console.log(greeting);

    // function declaration (statement) - SIMPLIFIED
    const welcomeMessageSimplified = function (message) {
      console.log(message);
    };
    welcomeMessageSimplified(
      "C.RE.A.M - Cash Rules Everything Around Me -  "
    );

    // function declaration (statement)

    // checkFuncDeclaration(); // => Func declaration CAN be invoked before it's defined.

    function checkFuncDeclaration() {
      console.log("Func declaration CAN be invoked before it is defined.");
    }

    // function expression

    // checkFuncExpression(); // => ReferenceError: checkFuncExpression is not defined

    // const checkFuncExpression = function () {
    //   console.log("Func expression CAN NOT be invoked before it is defined.");
    // };
    // ESTA FUNCION DA ERROR

    // anonymous function as other function arguments - example 1
    function printName(name, anonFunc) {
      anonFunc(name);
    }

    // printName("sandra", function (name) {
    //   console.log(name[0].toUpperCase() + name.slice(1));
    // });

    // anonymous function as other function arguments - example 2
    function getLength(str, anonFunc) {
      anonFunc(str);
    }

    // getLength("pauman", function (str) {
    //   console.log(`${str} has ${str.length} letters.`);
    // });
    // console.log(getLength);

    // getLength("noemi", function (str) {
    //   console.log(`${str} has ${str.length} letters.`);
    // });

    // anonymous function as other function arguments - example 3 - SETTIMEOUT
    // SETTIMEOUT: El m茅todo setTimeout() de JavaScript es un m茅todo incorporado que permite temporizar la ejecuci贸n de una determinada funci贸n . Es necesario pasar la cantidad de tiempo a esperar en milisegundos , lo que significa que para esperar un segundo, es necesario pasar mil milisegundos .

    // setTimeout(function () {
    //   console.log(
    //     "Quincy Jones, Sir George Martin & Phil Spector are by far the sickest producers of the 20th Century"
    //   );
    // }, 3000);
    // Nada pasa por tres segundos!

    // Dado que las funciones an贸nimas no est谩n disponibles para su uso posterior, si, por alguna raz贸n, tenemos la necesidad de utilizarlas, debemos darles una declaraci贸n de funci贸n adecuada o una estructura de expresi贸n de funci贸n. As铆 podremos referenciarlas y utilizarlas siempre que lo necesitemos.
    function notifyUser() {
      console.log(
        "Neil Frances, 40Nights&40Days, LargeProffesor, Dj Premier, Kevin Parker, Mark Ronson and believe or not, freaking Dave Ghrol are the producers with more grammy nominations within the last 20 years in the 'Producers Category' of music "
      );
    }

    // setTimeout(notifyUser, 6000);

    //Arrow Functions
    // arrow function syntax

    // function expression syntax
    // const greetingWithoutArrow = function (name) {
    //   console.log(`Hello, ${name}!`);
    // };
    // console.log(greetingWithoutArrow("Diego"));

    // const greetingWithArrow = (name) => {
    //   return name;
    // };
    // console.log(`Hello ${greetingWithArrow("Aleix")}`);

    //Pero esta funci贸n se puede acortar a煤n m谩s, ya que s贸lo devolvemos una expresi贸n (s贸lo hay una l铆nea de c贸digo en el cuerpo), por lo que podemos omitir los corchetes y omitir el retorno, ya que est谩 impl铆cito:
    const greetingWithArrowShorter = (name) => `Hello, ${name}!`;
    // console.log(greetingWithArrowShorter("Jarko"));

    //En caso de que no se pasen par谩metros - entonces los par茅ntesis vac铆os son obligatorios:
    const greetingWithoutParameters = () =>
      console.log("Hello there you Javascript Lovers!");
    // console.log(greetingWithoutParameters());

    //USING THE KEYWORD THIS
    const user = {
      name: "Diego",
      age: 31,
      getOlder: function () {
        console.log(this);
        console.log(this.name);
      },
    };
    // console.log(user.getOlder());
    //Como podemos ver, la palabra clave this se refiere al propio objeto (usuario). As铆 que si quisi茅ramos a帽adir un a帽o a la edad de Diego, podr铆amos actualizar nuestro c贸digo de la siguiente manera:
    const user2 = {
      name: "Diego",
      age: 31,
      getOlder: function () {
        this.age += 1;
        console.log(this.age);
      },
    };
    // console.log(user2.getOlder());

    //Genial. Ahora, vamos a a帽adir el m茅todo nativo de JS setInterval() para hacer que Diego sea "m谩s viejo" en un a帽o cada segundo:
    const user3 = {
      name: "Diego",
      age: 31,
      getOlder: function () {
        setInterval(function () {
          this.age += 1;
          console.log(this.age);
        }, 1000);
      },
    };
    // console.log(user3.getOlder());

    //Hmm... 驴qu茅 ha cambiado? Volvamos a sacar la palabra clave this:
    const user4 = {
      name: "Diego",
      age: 31,
      getOlder: function () {
        setInterval(function () {
          console.log(this);
        }, 1000);
      },
    };
    // console.log(user4.getOlder());
    // Parece que hemos "perdido" el acceso a las propiedades del objeto "usuario", ya que esta palabra clave se refiere ahora al m茅todo setInterval(). Simplificando, esto dentro de setInterval() se refiere al setInterval().

    //Entonces, 驴qu茅 podemos hacer para acceder a las propiedades que necesitamos?

    //La forma m谩s sencilla es utilizar la sintaxis de la funci贸n flecha, ya que vincula el 谩mbito al propio objeto. (M谩s adelante explicaremos el t茅rmino "bind" con m谩s detalle. En otras palabras, gracias a =>, ahora tenemos de nuevo acceso a las propiedades del "usuario").
    const user5 = {
      name: "Diego",
      age: 31,
      getOlder: function () {
        setInterval(() => {
          this.age += 1;
          console.log(this.age);
        }, 1000);
      },
    };
    // console.log(user5.getOlder());

    //USANDO ARGUMENTS
    function printSomething() {
      console.log(arguments);
    }

    // console.log(
    //   printSomething(
    //     "What else can a guitarrist do but, just learn from Hendrix, Howlin Wolf & John Frusciante"
    //   )
    // );

    //Podemos utilizar corchetes [] para acceder a los argumentos: arguments[0] devuelve el primer argumento, arguments[1] devuelve el segundo, y as铆 sucesivamente. Tambi茅n podemos utilizar la propiedad length del objeto arguments para determinar el n煤mero de argumentos.

    // function printSomething2() {
    //   console.log("arguments length: ", arguments.length);
    //   console.log("all: ", arguments);
    //   console.log("first arg: ", arguments[0]);
    //   console.log("second arg: ", arguments[1]);
    // }
    // console.log(printSomething2("Hello", "I love playing records"));

    //Como usamos estos argumentos?
    // function printArgs() {
    //   for (let i = 0; i < arguments.length; i++) {
    //     console.log(arguments[i]);
    //   }
    // }
    // console.log(printArgs("hey", "there", "ironhacker"));
    console.log(printArgs(1, 77, { name: "Diego" }, ["Guitar", "Piano"]));

    //Tengan en cuenta que los argumentos son un objeto, por lo que .forEach() y otros m茅todos espec铆ficos de los arrays no se pueden utilizar en 茅l. Si intentas utilizar m茅todos de array sobre 茅l, obtendr谩s un error similar a este:
    //TypeError: arguments.forEach is not a function

    //Sin embargo, debes tratarlo como un array cuando lo utilices en tu c贸digo. Aunque tiene algunas limitaciones, este "objeto tipo array" puede convertirse f谩cilmente en un array, si es necesario:
    // const args = Array.from(arguments);

    // EJEMPLO
    function useArgsAsArr() {
      const argsArr = Array.from(arguments);

      argsArr.forEach((el) => console.log(el));
    }
    // console.log(useArgsAsArr("I", "am", "iterated", "with", "forEach"));
  </script> -->
</html>
